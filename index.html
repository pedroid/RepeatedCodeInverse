<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Repeatedcodeinverse by pedroid</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Repeatedcodeinverse</h1>
        <p>Convert a paragragh of codes or words with regular rules into a function with for loop and statements.將有重覆規則的原始碼(或文字)轉換成一個迴圈+敘述句的格式</p>

        <p class="view"><a href="https://github.com/pedroid/RepeatedCodeInverse">View the Project on GitHub <small>pedroid/RepeatedCodeInverse</small></a></p>


        <ul>
          <li><a href="https://github.com/pedroid/RepeatedCodeInverse/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/pedroid/RepeatedCodeInverse/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/pedroid/RepeatedCodeInverse">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="repeatedcodeinverse" class="anchor" href="#repeatedcodeinverse" aria-hidden="true"><span class="octicon octicon-link"></span></a>RepeatedCodeInverse</h1>

<p>written by <a href="mailto:ntuyusheng@gmail.com">ntuyusheng@gmail.com</a></p>

<p>Convert a paragragh of codes or words with regular rules into a function with for loop and statements.
找到數行程式碼中數字遞迴的規則，產生"以迴圈產生該原始碼的程式"</p>

<p>當使用硬體描述語言開發數位電路時，因為電路的特色就是許多I/O 控制是平行在運行的. 因此常常會需要大量的宣告變數，以及指定值給這些變數。舉例來說，工作上我們若需要宣告64通道的I/O，並將這些通道訊號指定給特定的前級訊號。在原始碼上常常會看到這樣格式的內容：</p>

<pre><code>  #written in Verilog
  #register declaration
  reg [1:0] pin0;
  reg [1:0] pin1;
  reg [1:0] pin2;
  //...
  reg [1:0] pin63;

  #pin assignment
  always@(*)begin
    pin0 &lt;= 2'd0;
    pin1 &lt;= 2'd0;
    pin2 &lt;= 2'd0;
    //...
    pin63 &lt;= 2'd0;
  end
</code></pre>

<p>程式設計師為了節省時間，常常會開發小程式來協助工作上大量重覆的動作。要寫出上列的程式碼，常常會用其他語言(如Python)來產生該verilog 語法：</p>

<pre><code>for i in range(64):
  print 'reg [1:0] pin' + str(i)

print 'always@(*)begin'
for i in range(64):
  print '\tpin' + str(i) + '&lt;= 2\'d0'

print 'end'
</code></pre>

<p>這樣短短幾行就可以產生出我們想要的程式碼了，這真是一件很美好的事情。原本需要不斷的複製貼上，然後再一一修改變數的動作都免了，省了非常多的時候。</p>

<p>然而，工作上我們最常做的時候反而不是從零開始撰寫程式，而可能是承接前人的專案，或是將自己過去開發的程式再擴充、修改。比如說，我們可能要將64通道的系統擴充到128的系統，或是一群i/o加上一個可控制的遮罩，以供測試用。有時運氣好，我們可以找到之前寫的小程式，只要小小地修改參數後就可以輕鬆的完成這份工作。若是找不到或是不想花時間去檔案海中找，那重新寫一份可能是次快(搞不好更快)的方法。而在這個repo中開發的程式，可以幫助程式設計師找到程式碼中的遞迴邏輯，減少程式設計師重新寫符合原程式碼模式的時間。</p>

<p>延續之前的程式例子，我們想要把原本的程式碼改成如下：</p>

<pre><code>  #written in Verilog
  #register declaration
  reg [1:0] pin0;
  reg [1:0] pin1;
  reg [1:0] pin2;
  //...
  reg [1:0] pin127;

  #pin assignment
  always@(*)begin
    pin0 &lt;= enable[0]?2'd0:1;
    pin1 &lt;= enable[1]?2'd0:1;
    pin2 &lt;= enable[2]?2'd0:1;
    //...
    pin127 &lt;= enable[127]?2'd0:1;
  end
</code></pre>

<p>可以看到我們將通道擴充了(64-&gt;128)，此外為了每個pin都能獨立測試，在每個pin上都各別加上了一個開關。這個動作在某些工作中滿常見的。一般而言，若是沒有原始產生該段程式碼的開發程式，我們還是可以從頭去撰寫，這估計也花不了多少時間，然而，重新寫作這件事情本身也是一個重覆的動作不是嗎？當然要有法子來幫助懶惰的程式設計師減輕我們的負擔啦。RepeatedCodeInverse就是基於這個目的下去開發的！</p>

<p>使用上，分成幾個步驟：
1、將想要改寫的程式碼獨立擷取出來到一文字檔
2、執行RepeatedCodeInverse工具，將步驟一的文字檔作為程式的輸入，
3、程式判斷出該段程式的遞迴規律，並輸出以特定語法(預設為python)的程式碼
4、使用者去修改該程式碼，改變自己想要的變數，在本文件所列舉中的例子為通道數，以及加入遮罩
5、輸出程式碼，並貼回自己的程式。</p>

<p>example1:(written in python)</p>

<pre><code>from fn_inverse_verilog import ContinuousNumList2Rule, RepeatedCodeInverse
#read in file
filename = 'example1.txt'
f = open(filename, 'r')
AllLine = f.readlines()
RepeatedCodeInverse(AllLine)
</code></pre>

<p>程式的輸出：</p>

<pre><code>for i in range(64):
    print 'reg [' + str( 1+i*(0)) + ':' + str( 0+i*(0)) + '] pin' + str( 0+i*(1)) + ''
</code></pre>

<p>若要將程式修改為128 的版本，就只要修改對應的參數即可：</p>

<pre><code>for i in range(128):
    print 'reg [' + str( 1+i*(0)) + ':' + str( 0+i*(0)) + '] pin' + str( 0+i*(1)) + ''
</code></pre>

<p>example2:(written in python)</p>

<pre><code>from fn_inverse_verilog import ContinuousNumList2Rule, RepeatedCodeInverse
#read in file
filename = 'example2.txt'
f = open(filename, 'r')
AllLine = f.readlines()
RepeatedCodeInverse(AllLine)
</code></pre>

<p>程式的輸出：</p>

<pre><code>for i in range(64):
    print ' pin' + str( 0+i*(1)) + '&lt;= ' + str( 2+i*(0)) + ''d' + str( 0+i*(0)) + ''
</code></pre>

<p>若要將程式修改為128 的版本，就只要修改對應的參數即可：</p>

<pre><code>for i in range(128):
    print ' pin' + str( 0+i*(1)) + '&lt;= enable[' + str(i) + ']?' + str( 2+i*(0)) + ''d' + str( 0+i*(0)) + ':0;'
</code></pre>

<p>(全篇完) </p>

<p>註：考慮到使用上的方便，所以用javascript也寫了一個網頁版，再加上HTML、CSS在UI上作設計，使得若是想要用這個工具，將javascript/這個資料夾copy到個人電腦即可使用，不需上網，也不需安裝額外程式，只要有瀏覽器即可。</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/pedroid">pedroid</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-19143938-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
